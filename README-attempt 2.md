# Simple Parser Generator

## Introduction
This Git repository contains code and documentation for the Simple Parser Generator(SPG), which is a system for generating parsers. This README serves as a kind of manual for using it, including details about installation, concepts, the internal language H1, examples, and details on the overall operation. The SPG currently only has a JavaScript implementation.

## General overview
The SPG implements a V1 virtual machine which is a special minimilistic virtual machine that is meant to operate many small parsing nodes operating together. Parsers are written in the H1 language, and get loaded into memory by the SPG Generator object which converts a text representation of a parser into an in-memory parsing program that runs on the V1 virtual machine.

To understand how the SPG works, it is necessary to understand how the V1 virtual machine works.

## The V1 virtual machine.

The V1 virtual machine is a kind of computer. It takes in a single input as a string and produces a JavaScript object as output.


The SPG system uses abstractions to describe parsers:
1) A virtual machine called V1
2) The parser description language H1, which describes the workings of an in-memory parser that runs on the V1 virtual machine.
3) A Generator object that converts parsers written in the H1 language into an in-memory parser that runs on the V1 virtual machine





Parsers using the SPG system are described in the H1 language. The SPG and the SPG Generator object converts an H1 file or string into an in-memory parser that runs according to the V1 model 


## Installation

The executable portion of the code is located in the file releases/spg.js, which can be obtained by cloning the github repository located at https://github.com/raymond1/simple-parser-generator/. The installation instructions for a NodeJS installation and for a browser installation are shown below.

### NodeJS installation instructions using NPM
1. Make a new package.json file. This can be done with the command npm init and pressing enter through all the prompts to use the default options.
2. Add or set the "type" attribute in the package.json file to the value "module".
3. In a terminal, run the command

```
npm install git+https://github.com/raymond1/simple-parser-generator.git#v2
```

4. At this point, the simple parser generator should be installed. To use it, create a file called index.js and use an import statement. For example:

```
import {Generator} from 'simple-parser-generator'
```

### Browser installation instructions
1. Set up a web server that can serve HTML and JavaScript pages with the correct Content-Type headers.
2. Create a small website containing an index.html file and put it into the document root or public_html folder or other folder where your web server will be serving.
3. Clone the https://github.com/raymond1/simple-parser-generator#v2 repository.
4. Copy the file releases/spg.js into the folder that your web server is serving.
5. In your index.html file, add the following just before the end of your body tag:
```
    <script type="importmap">
      {
        "imports": {
          "simple-parser-generator":"./spg.js"
        }
      }
    </script>
    <script type="module">
import {Generator} from 'simple-parser-generator'
    </script>
```

## Quick start

After going through the installation steps above, you will have access to a Generator object. The following quick start sample program is a minimalistic JavaScript stub program that explains from a software development point of view how to generate a parser using the SPG on the NodeJS platform. Details on the conceptual model will be explained after describing the quick start software workflow.

### Quick Start Sample Program
This following quick start sample program demonstrates the software workflow for making a simple parser and using it to parse an input string. The comments will explain each line's purpose.

```
/* 1. Import the 'Generator' class.*/
import {Generator} from 'simple-parser-generator' 

/* 2. Instantiate a new Generator object. */
let generator = new Generator()

/* 3. Specify the parser using the H1 programming language. */
let specification = 
`string literal
 world`

/* 4. Generate a parser object from the specification. */
let parser = generator.generateParser(specification)

/* 5. Create an input string to be fed into your parser. */
let inputString = 'world'

/* 6. Parse the input string using the generated parser and save the output in a variable.*/
let output = parser.parse(inputString)

/* 7. At this point, the "output" variable will contain some information. The exact format of this information is described in more detail later on. */
```

## Using the SPG.

In order to use the SPG, it is necessary to understand how to specify the parser using the H1 language and also the output data generated by the parser. This next subsection describes the H1 file format.

### Basic Space Tree syntax of the H1 parser specification language

The H1 language is used to describe parsers and is built upon the T1 Space Tree Notation(hereafter referred to simply as the Space Tree Notation) used to describe tree structures. The information from these tree structures are passed into the parser generator to create a parser.

In order to understand the H1 language, it is necessary to first understand the Space Tree Notation. Syntactically, strings or files that conform to the Space Tree notation consists of lines of text. Each line of text contains a single piece of string information with zero or more leading spaces.

Space Tree files look like this:

```
<string>
 <string>
  <string>
   <string>
 <string>
  <string>
   <string>
 <string>
  <string>
   <string>
    <string>
     <string>
     <string>
      <string>
  <string>
```
Conceptually, each line from a file or string written in Space Tree Notation represents a node in the tree, and the string data associated with each node in the tree is equal to the string contents of the line, without the leading spaces.

The hierarchical relationship amongst the nodes in the tree is indicated by the number of leading spaces on the left of a line. In the terminology of the Space Tree Notation, the number of leading spaces on the left is known as the 'depth' of a line. 

Two lines are considered siblings if they both have the same depth and there are no intervening lines which have a smaller depth number.

A line A1 is the parent of line B1 if three conditions hold:
1) the depth of B1 is equal to one greater than the depth of A1
2) line B1 comes after line A1
3) There are no intervening lines with a depth less than the depth of line A in between line A1 and line B1

To illustrate how this hierarchical tree information and associated node data are enocded, consider the following file which conforms to the Space Tree Notation:

```
A
 B
  C
 D
  E
   F
```

The following table shows the relationship between the line number, number of leading spaces, depth, parent line number and the node information associated with each line for the sample H1 file shown above:

Line number | Depth | Parent line number | String information associated with the node
--------------------------------------------------------------------------------------
1           | 0     | None               | A
2           | 1     | 1                  | B
3           | 2     | 2                  | C
4           | 1     | 1                  | D
5           | 2     | 4                  | E
6           | 3     | 5                  | F

Although this gives a good basic understanding of how tree information is stored inside Space Tree files, there are some subtleties which have been glossed over, such as how to encode the space character at the beginning of a line, or how to encode the line feed character.

This information will be produced in the future. For now, just avoid those characters. It is not necessary to understand these subtleties in order to understand the general workings of the H1 file format used by the SPG.

### The H1 file format

The H1 language uses the Space Tree Notation to express tree information but this tree information must additionally conform to a schema in order to be a valid H1 file.

Conceptually, the H1 language is an abstraction of a tree of instruction nodes. The SPG will take in an H1 file or string and convert it into an in-memory tree of instruction nodes. Then, when parsing begins, the instruction nodes will be run in sequence starting with the first one, and continuing on to the next instruction until there are no more instructions to be executed.

The first line in the H1 file format must begin with a string that comes from a fixed list of instruction literals. Instruction literals are one of the following:

List of instruction literals:
1. character class
2. string literal
3. not
4. entire
5. sequence
6. or
7. and
8. multiple
9. optional
10. split
11. name
12. jump

These instruction literals represent the atomic operations that will be executed by the SPG virtual machine during parsing. The SPG virtual machine is called the V1 virtual machine, and the different instructions have different effects on the virtual machine.

In order to understand the effects of each of the instructions that are possible, it is first necessary to understand some background about the V1 virtual machine.






to generate an operational in-memory parser. Some atomic operations will require zero child nodes, and others will require more. Some of the atomic operations requiring child nodes will require a string piece of information, and others will require another atomic operation as a child node.


-----------------------




Schema

-----------


To determine the conceptual tree structure that this represents, the overall procedure is as follows:

1. Use the H1 file to construct a tree called A1.
2. Extract a second tree from A1 whose nodes consist of only instruction nodes which each have 0 or more attributes. Call this tree the A2 tree or the instruction node tree.

For step 1, the leading spaces on each line stores the parent-child relationship information of the tree. The number of leading spaces before the first character on a line represents its depth in the tree. If a line has a depth of n, then it will be the child node of the first line that has a lower line number that has a depth of n-1.

Lines with n leading spaces will be children of the first line above it that have n-1 leading spaces. If a line has a greater depth than the line immediately above it, then it is a child of that line.

As an example, here is a table showing the relationship between the line number, depth and parent line number for the sample H1 file from above:

Line number | Depth | Parent line number
----------------------------------------
1           | 0     | None
2           | 1     | 1
3           | 2     | 2
4           | 1     | 1
5           | 2     | 4
6           | 3     | 5

By convention, all nodes with a depth 0 are considered to be children of a theoretical node of depth -1, called the root node. This is just a convention so that you can say that all H1 files describe a single tree.

One the A1 tree has been constructed, the tree's nodes are divided into 'data nodes' and 'instruction nodes'. The A2 tree will absorb all data nodes, which have no children, into their parent nodes as attributes.This A2 tree is the conceptual model of the list of instructions that lie in memory.

Whether a node is a data node or an instruction node is context-sensitive and is determined using the algorithm described in the section [How to determine if a node is a data node or an instruction node](how-to-determine-if-a-node-is-a-data-node-or-an-instuction-node).

### How to determine if a node is data or an instruction

If a node in the A1 tree has a depth of 0, then it should be an instruction node. For a node to be an instruction node means that the portion of the line in the H1 file that the A1 tree was derived that when stripped of leading spaces must contain an instruction node name. An instruction node name can be any one of the following:

1. character class
2. string literal
3. not
4. entire
5. sequence
6. or
7. and
8. multiple
9. optional
10. split
11. name
12. jump

The above list acts like keywords in other languages. Each instruction node has a schema rule associated with it, meaning that the number of children it has is specified, and the order of its children has a specific meaning. The schema rule for each instruction type is given in the following table, called the V1 schema rule table:

Type of node    | number of children | Type of child node or nodes
-----------------------------------------------------
character class | 1                  | data
string literal  | 1                  | data
not             | 1                  | instruction
entire          | 1                  | instruction
sequence        | 1 or more          | instruction
or              | 2 or more          | instruction 
and             | 2 or more          | instruction
multiple        | 1                  | instruction
optional        | 1                  | instruction
split           | 1 or more          | instruction
name            | 2                  | First child is a data node. Second child is an instruction.
jump            | 1                  | data (must match with data from a name node)

Assuming that the A1 tree starts with an instruction node and follows the schema rules, it is possible to start from the first node in an A1 tree, and, using the above table, proceed to determine whether each node in the A1 tree is an instruction or a data node.

For example, in the tutorial sample file, line 1 is a sequence node. In the schema rule table, sequences have one or more children. The type of these children is 'instruction'. Therefore, all of the children of the sequence node will be interpreted to be instructions. That means lines 2 and 4 are instructions.

Line 2 is a string literal node. According to the schema rule table, string literal nodes have one data type child. Therefore, line 3, which is the child of line 2 must be a data line.

Line 4 is a 'multiple' type node. According to the schema rule table, 'multiple' type nodes have one instruction child. Therefore, line 4's child line, which is line 5, is also an instruction.

Line 5 is a 'character class' node. According to the schema rule table, 'character class' nodes have one child, which is a data type node. Therefore, line 6, which is the child of line 5, must be a data line.

Any correctly formatted H1 file that obeys the V1 schema rules can thus be divided into data and instruction nodes/lines.

### Constructing the A2 tree from the A1 tree
The A2 tree consists of all the instruction nodes of the A1 tree with any data nodes absorbed as attributes of their parent instruction node. For example, in the tutorial sample H1 file, line 3, which is a data node, is interpreted to be a property of line 2, which is its parent instruction node, and line 6, which is a data node, is also interpreted to be a property of the node created from line 5.

### Operation of the V1 virtual machine

The V1 virtual machine holds several pieces of stateful information. The description of how the V1 virtual machine's state changes from one state to another sums up the workings of the machine.

The 3 main pieces of stateful of the V1 virtual machine are the following:

1. The input string.
2. An A2 tree in memory consisting of instruction nodes whose description was derived from an H1 file and which may contain internal state themselves.
3. An output object storage area in memory that stores output objects generated during the execution of the V1 virtual machine.

The output objects generated by the storage area hold parsing information, which is information about which segments of the input string belong to which internal structure. This is stored in tree format, so the output objects represent a tree.

Passing in different values for the input string and the H1 file will result in different output objects being generated. The exact output objects that will be generated will depend on what input string and which instruction nodes make up the A2 tree that is passed in.

###

Execution starts on the first instruction node of the A2 tree and proceeds from there. In general, unless a node is a character class node or a string literal node, its results will depend on the results of other nodes.











Execution starts from the first node of the A2 tree.


As execution progresses, the output 

In addition
2. A numeric index called the input string pointer, which points to a particular character on the input string.
matchFound
matchString

In addition, each node in the A2 tree can potentially store internal state, leading to complex interactions between nodes

The input string, the input string pointer, matchFound, matchString, the A2 tree and the program pointer are all initially undefined. They become defined after the V1 virtual machine has been initialized with an input string and an H1 file.

Once the V1 virtual machine has been initialized with both an input string and H1 file, the machine automatically initializes its input string pointer to be 0, sets matchFound to be false, matchString to be false, sets its A2 tree to be the A2 image of the H1 file, sets the program pointer to the first instruction of the A2 tree, and has an empty output object storage area.

Then, when the V1 virtual machine's parse function is triggered, the first instruction node begins execution. Depending on what the node is, the V1 machine will be affected differently. Many instructions can only finish computing once their child instructions finish computing.

It's best to use an example to show how this works.











initialization proceeds as follows:



All these values are undefined
### Initialization of the V1 virtual machine

A V1 virtual machine starts with its input string undefined. The input string caret is set to the value 0. The true or false flag called matchFound is set to false. The string value called matchString is set to the empty string. The A2 tree is initially empty. 

1. The input string is basically the input data that will be fed to the V1 virtual machine. It is programmed as in comment 6 of the tutorial sample program.

2. The caret points initially to the first character of the input string.

3. The matchFound flag of the V1 virtual machine is initially set to false.

4. The string called matchString of the V1 virtual machine is initially set to the empty string, ''.

5. The set of instructions loaded into a V1 virtual machine can be set as in comments 3 and 4 from the tutorial sample program.

6. Initially, the program pointer points to the image of the first line from the H1 program loaded into memory.

7. Initially, the storage location in memory that stores output objects is empty. This is basically a collection or an array or list that begins empty.



-----------------------------------------








The nodes and their effects on the V1 virtual machine are listed in the [Nodes API section](nodes-api).



















### Nodes API

1. Character Class

string indicator: 'character class'
match length: equal to the number of characters.
caret: 

Type of node

character class

Effect:
Takes in a 

                    | data


string literal  |                    | data
not             |                    | instruction
entire          |                    | instruction
sequence        |                    | instruction
or              |           | instruction 
and             |           | instruction
multiple        |                   | instruction
optional        |                   | instruction
split           |           | instruction
name            | 2                  | First child is a data node. Second child is an instruction.
jump            | 1                  | data (must match with data from a name node)


It is this A2 tree that forms the conceptual model of an H1 file that follows the V1 schema rule table.


After the A1 tree has been created, and the nodes of the A1 tree have been divided into data and instruction nodes, the A2



1. The character class node has only one child node, and that child node must be


To determine whether a node from the A1 tree is a data node or an instruction node, it is first necessary to enumerate all the possible types of instruction nodes.

The complete list of instruction nodes is:


These instruction nodes are essentially equivalent to keywords used in other languages.

If

------------------------



Besides the leading spaces, each line in the H1 file format contains only one piece of information. A line may contain either the name of an instruction or data encoded as an H1-encoded string string. If a line contains an instruction, it is called an 'instruction node' or simply an 'instruction'. Whether a line is an instruction or a piece of data is context sensitive.

Interpretation starts from line 1 and then proceeds downwards. If a line is a non-terminal node, it means that it is a node that is capable of having one or more nodes as children. If a line is a terminal node, then it means that its only children will be data nodes.







Each instruction from this list is called a 'node name', a 'node type', a 'node object' or a 'node'. If a line is not a node, then it contains a piece of data. Data lines store string information in an encoding called 'M1-escaped format'. Each piece of data is the child of exactly one node object.

A node's children are called 'child elements' and can be either data or nodes.

In M1-escaped format, special characters are replaced with a replacement string. The table of special characters and their replacements is shown below:

character | replacement
-----------------------
(         | ENC(L)
)         | ENC(R)
,         | ENC(C)
(space)   | ENC(S)
(newline) | ENC(N)

In addition, any unicode character can be encoded by the string ENC(X), where X is a non-negative base 10 number. In the H1 language, strings are encoded as unicode strings.

Each node type requires 0, 1, or more child elements and influences the V1 virtual machine in different ways. The different nodes and their effects on the V1 virtual machine's execution is described in section [Programming a parser using the nodes of the H1 language](#programming-a-parser-using-the-nodes-of-the-h1-language).


## API

The API documentation for pubicly available GeneratorGenerator methods is available in the [API documentation](documentation/api/index.html file).
let parser = Generator.setGrammar(s)
parser.parse(s)

# Status

The Simple Generator Generator is currently in its second generation and is undergoing testing and bug fixes. 

## Demo programs
 
Demo programs are available in the documentation/demos folder. The demos will probably work if you can serve the demos folder with the correct MIME types.

The nodejs_installation demos should work on NodeJS.