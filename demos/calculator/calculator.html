<html lang="en">
<head>
<title>Calculator</title>
<meta charset="utf-8"/>
</head>
<body>
<div id='test'></div>
<div id="output"></div>
<button type='button' onclick='evaluateExpression()'></button>
<script src='../../releases/parser.js'></script>
<script>
let grammar = `

EXPRESSION = OR[
	ADDITION_EXPRESSION,
	SUBTRACTION_EXPRESSION,
	INTEGER
]

INTEGER = CHARACTER_CLASS['0123456789']

ADDITION_EXPRESSION = SEQUENCE[
	INTEGER,
	'+',
	EXPRESSION
]

SUBTRACTION_EXPRESSION = SEQUENCE[
	INTEGER,
	'-',
	EXPRESSION
]
`

class TreeProcessor{
	constructor(ast){
		this.ast = ast
	}

	//Generates a tree consisting only of the matched user defined rules
	getRuleMatchesOnly(){

	}

	//matches are guaranteed to be contiguous
	getMatchesOnly(ast){
		let newNode = null
		if (ast.matchFound == true){
			newNode = this.shallowCopy(ast)
			newNode.internalMatches = []
			if (ast.internalMatches){
				if (Array.isArray(ast.internalMatches)){
					for (let internalMatch of ast.internalMatches){
						if (internalMatch.matchFound == true){
							newNode.internalMatches.push(this.getMatchesOnly(internalMatch))
						}
					}
				}
				else {
					//assume that ast.internalMatches is an object
					newNode.internalMatches.push(this.getMatchesOnly(ast.internalMatches))
				}
			}
		}
		
		return newNode
	}

	//This is a helper method to getMatchesOnly
	//copies all attributes one node, except for internalMatches
	shallowCopy(ast){
		let newNode = new Node()
		for (let attribute in ast){
			if (!Array.isArray(ast[attribute])){
				newNode[attribute]=ast[attribute]
			}
		}
		return newNode
	}
}

let parser = new Parser()
parser.setGrammar(grammar)

let input = '100-1'
let output = parser.parse(input)

let treeProcessor = new TreeProcessor(output)

let matchesOnly = treeProcessor.getMatchesOnly(output)
debugger
let treeViewer = new TreeViewer(matchesOnly, document.querySelector('#test'))
treeViewer.display()

/*
let evaluateExpression = function(expressionTree){

}*/
</script>
</body>
</html>
