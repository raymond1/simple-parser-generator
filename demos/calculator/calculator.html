<html lang="en">
<head>
<title>Calculator</title>
<meta charset="utf-8"/>
</head>
<body>
<div id='test'></div>
<div id="output"></div>
<button type='button' onclick='evaluateExpression()'></button>
<script src='../../releases/parser.js'></script>
<script>
let grammar = `

EXPRESSION = OR[
	ADDITION_EXPRESSION,
	SUBTRACTION_EXPRESSION,
	INTEGER
]

INTEGER = CHARACTER_CLASS['0123456789']

ADDITION_EXPRESSION = SEQUENCE[
	INTEGER,
	'+',
	EXPRESSION
]

SUBTRACTION_EXPRESSION = SEQUENCE[
	INTEGER,
	'-',
	EXPRESSION
]
`

class TreeProcessor{
	constructor(){
	}

	//returns all nodes in a list
	//Test is a function you can pass in to return only certain nodes
	//If test is passed in and is not null, then 
	returnAllNodes(ast, test = null){

		//The default test always returns true, in effect returning all nodes
		if (test == null){
			test = function(){
				return true
			}
		}

		let nodesToReturn = []
		if (test(ast)){
			nodesToReturn.push(this.shallowCopy(ast))
		}

		for (let match of ast.matches){
			let childNodes = this.returnAllNodes(match, test)
			nodesToReturn = nodesToReturn.concat(childNodes)
		}
		return nodesToReturn
	}

	//Removes a node from a tree and rejoins it
    //          root
	//           |
	//           A
	//          / \
    //          B C
	//         /| |\
	//        / | | \
	//       D  E F  G
	//       |
    //       H
	//       |
	//       I
	//
	//I assume the root cannot be removed. All other nodes can be removed
	//If A is removed, then B and C will be children of the root.
	//If C is removed, then F and G become children of A
	//If D is removed, then H and I become children of B
	//If E is removed, no additional healing of the tree will take place
	removeAndHeal(ast){
		if (ast){
			let parent = ast.parent

			//If ast node has a parent that is not null, then the current node must be removed from its matches list
			if (parent){
				for (let i = 0; i < parent.matches.length; i++){
					if (parent.matches[i] == ast){
						parent.matches.splice(i,1)
						break
					}
				}
			}

			//For each match in the current node, if there is a parent, then the parent must add the matches to its matches list
			for (match in ast.matches){
				if (ast.parent){
					ast.parent.matches.push(match)
					match.parent = ast.parent
				}
			}

			//All the children must set their parent to the parent of ast
			for (match in ast.matches){
				match.parent = parent
			}
		}
	}

	//Generates a tree consisting only of the matched user defined rules
	getRuleMatchesOnly(ast){
		//Step 1: add parent property to the ast
		let newAst = this.addParentForChildren(ast)
		let newNode = null
	}

	//matches are guaranteed to be contiguous
	getMatchesOnly(ast){
		let newNode = null
		if (ast.matchFound == true){
			newNode = this.shallowCopy(ast)
			newNode.matches = []
			if (ast.matches){
				for (let match of ast.matches){
					if (match.matchFound == true){
						newNode.matches.push(this.getMatchesOnly(match))
					}
				}
			}
		}
		
		return newNode
	}

	//This is a helper method to getMatchesOnly
	//copies all attributes one node, except for matches
	shallowCopy(ast){
		if (ast == null){
			return null
		}

		let newNode = new Node()
		for (let attribute in ast){
			if (!Array.isArray(ast[attribute])){
				newNode[attribute]=ast[attribute]
			}
		}
		return newNode
	}
}

let parser = new Parser()
parser.setGrammar(grammar)

let input = '100-1'
let output = parser.parse(input)

let treeProcessor = new TreeProcessor(output)

let matchesOnly = treeProcessor.getMatchesOnly(output)

let ruleNodes = treeProcessor.returnAllNodes(matchesOnly, (ast)=>{ return ast.type == 'rule'})

let ruleIds = []
for (let ruleNode of ruleNodes){
	ruleIds.push(ruleNode.id)
}

let testClosure = (function(){
	var _ruleIds = ruleIds
	var innerFunction = function(ast){
		return _ruleIds.includes(ast.id)
	}
	return innerFunction
})()

//Why am I getting doubles?
let nodesToDelete = treeProcessor.returnAllNodes(output, testClosure)

let treeViewer = new TreeViewer(nodesToDelete, document.querySelector('#test'))
treeViewer.display()

/*
let evaluateExpression = function(expressionTree){

}*/
</script>
</body>
</html>
