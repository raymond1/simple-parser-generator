<html lang="en">
<head>
<title>Calculator</title>
<meta charset="utf-8"/>
</head>
<body>
<div id='test'></div>
<div id="output"></div>
<button type='button' onclick='evaluateExpression()'></button>
<script src='../../releases/parser.js'></script>
<script>
let grammar = `

EXPRESSION = OR[
	ADDITION_EXPRESSION,
	SUBTRACTION_EXPRESSION,
	INTEGER
]

INTEGER = CHARACTER_CLASS['0123456789']

ADDITION_EXPRESSION = SEQUENCE[
	INTEGER,
	'+',
	EXPRESSION
]

SUBTRACTION_EXPRESSION = SEQUENCE[
	INTEGER,
	'-',
	EXPRESSION
]
`

class TreeProcessor{
	constructor(ast){
		this.ast = ast
	}

	//Removes a node from a tree and rejoins it
    //          root
	//           |
	//           A
	//          / \
    //          B C
	//         /| |\
	//        / | | \
	//       D  E F  G
	//       |
    //       H
	//       |
	//       I
	//
	//I assume the root cannot be removed. All other nodes can be removed
	//If A is removed, then B and C will be children of the root.
	//If C is removed, then F and G become children of A
	//If D is removed, then H and I become children of B
	//If E is removed, no additional healing of the tree will take place
	removeAndHeal(node){

	}

	//Create a new AST tree such that for each node, add a parent property if possible
	cloneAndAddParent(ast, parentNode = null){
		let clonedNode = this.shallowCopy(ast)
		clonedNode.parentNode = parentNode
		clonedNode.internalMatches = []
		if (clonedNode != null){
			for (let internalMatch of ast.internalMatches){
				internalMatch.parent = clonedNode
				clonedNode.internalMatches.push(internalMatch)
			}
		}
		return clonedNode
	}

	//Generates a tree consisting only of the matched user defined rules
	getRuleMatchesOnly(ast){
		//Step 1: add parent property to the ast
		let newAst = this.addParentForChildren(ast)
		let newNode = null
	}

	//matches are guaranteed to be contiguous
	getMatchesOnly(ast){
		let newNode = null
		if (ast.matchFound == true){
			newNode = this.shallowCopy(ast)
			newNode.internalMatches = []
			if (ast.internalMatches){
				for (let internalMatch of ast.internalMatches){
					if (internalMatch.matchFound == true){
						newNode.internalMatches.push(this.getMatchesOnly(internalMatch))
					}
				}
			}
		}
		
		return newNode
	}

	//This is a helper method to getMatchesOnly
	//copies all attributes one node, except for internalMatches
	shallowCopy(ast){
		if (ast == null){
			return null
		}

		let newNode = new Node()
		for (let attribute in ast){
			if (!Array.isArray(ast[attribute])){
				newNode[attribute]=ast[attribute]
			}
		}
		return newNode
	}
}

let parser = new Parser()
parser.setGrammar(grammar)

let input = '100-1'
let output = parser.parse(input)

let treeProcessor = new TreeProcessor(output)

let matchesOnly = treeProcessor.getMatchesOnly(output)

let cloneWithParents = treeProcessor.cloneAndAddParent()
debugger
let treeViewer = new TreeViewer(matchesOnly, document.querySelector('#test'))
treeViewer.display()

/*
let evaluateExpression = function(expressionTree){

}*/
</script>
</body>
</html>
