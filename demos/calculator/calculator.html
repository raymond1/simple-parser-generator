<html lang="en">
<head>
<title>Calculator</title>
<meta charset="utf-8"/>
</head>
<body>
<div id='test'></div>
<div id="output"></div>
<button type='button' onclick='evaluateExpression()'></button>
<script src='../../releases/parser.js'></script>
<script>
let grammar = `

EXPRESSION = OR[
	ADDITION_EXPRESSION,
	SUBTRACTION_EXPRESSION,
	INTEGER
]

INTEGER = CHARACTER_CLASS['0123456789']

ADDITION_EXPRESSION = SEQUENCE[
	INTEGER,
	'+',
	EXPRESSION
]

SUBTRACTION_EXPRESSION = SEQUENCE[
	INTEGER,
	'-',
	EXPRESSION
]
`

//Usage: let a = new TreeProcessor()
class TreeProcessor{
	constructor(){
	}

	//returns all nodes in a list
	//Test is a function you can pass in to return only certain nodes
	//If test is passed in and is not null, then 
	returnAllNodes(matchTree, test = null){

		//The default test always returns true, in effect returning all nodes
		if (test == null){
			test = function(){
				return true
			}
		}

		let nodesToReturn = []
		if (test(matchTree)){
			nodesToReturn.push(matchTree)
		}

		for (let match of matchTree.matches){
			let childNodes = this.returnAllNodes(match, test)
			nodesToReturn = nodesToReturn.concat(childNodes)
		}
		return nodesToReturn
	}

	//Removes a node from a tree and rejoins it
    //          root
	//           |
	//           A
	//          / \
    //          B C
	//         /| |\
	//        / | | \
	//       D  E F  G
	//       |
    //       H
	//       |
	//       I
	//
	//I assume the root cannot be removed. All other nodes can be removed
	//If A is removed, then B and C will be children of the root.
	//If C is removed, then F and G become children of A
	//If D is removed, then H and I become children of B
	//If E is removed, no additional healing of the tree will take place
	removeItemAndHeal(itemToRemove, matchTree){
		if (itemToRemove == null){
			throw "Cannot remove null from a tree."
		}
		if (matchTree == null){
			throw "Cannot remove an item from an empty tree."
		}

		if (matchTree === itemToRemove){
			//If matchTree node has a parent that is not null, then the current node must be removed from its matches list
			if (matchTree.parent){
				if (!matchTree.parent.matches){
					debugger
				}
				for (let i = 0; i < matchTree.parent.matches.length; i++){
					if (matchTree.parent.matches[i] == matchTree){
						matchTree.parent.matches.splice(i,1)
						break
					}
				}
			}

			//For each match in the current node, if there is a parent, then the parent must add the matches to its matches list
			for (let match of matchTree.matches){
				if (matchTree.parent){
					matchTree.parent.matches.push(match)
					match.parent = matchTree.parent
				}
			}

			//All the children must set their parent to the parent of matchTree
			for (let match of matchTree.matches){
				match.parent = matchTree.parent
			}
		}else{
			//check if children need to be removed
			//All the children must set their parent to the parent of matchTree
			for (let match of matchTree.matches){
				this.removeItemAndHeal(itemToRemove,match)
			}
		}
	}


	//matches are guaranteed to be contiguous
	getRuleMatchesOnly(matchTree){
		return this.returnAllNodes(matchTree, (matchTreeNode)=>{return matchTreeNode.matchFound&&matchTreeNode.type == 'rule'})
	}

	//clones scalar attributes(not arrays)
	imperfectClone(matchTree){
		let newMatchTree = null
		if (matchTree.matchFound == true){
			newMatchTree = this.shallowCopy(matchTree)
			newMatchTree.matches = []
			if (matchTree.matches){
				for (let match of matchTree.matches){
					if (match.matchFound == true){
						newMatchTree.matches.push(this.imperfectClone(match))
					}
				}
			}
		}
		
		return newMatchTree
	}

	//This is a helper method to getMatchesOnly
	//copies all attributes one node, except for matches
	shallowCopy(ast){
		if (ast == null){
			return null
		}

		let newNode = {}
		for (let attribute in ast){
			if (!Array.isArray(ast[attribute])){
				newNode[attribute]=ast[attribute]
			}
		}
		return newNode
	}

	//performs a shallow operation on all nodes that match selectionTest and are not null
	recursiveApply(matchNode, operation, selectionTest){
		if (matchNode){
			if (selectionTest(matchNode)){
				operation(matchNode)
			}

			for (let match of matchNode.matches){
				this.recursiveApply(match,operation,selectionTest)
			}
		}
	}
}

let parser = new Parser()
parser.setGrammar(grammar)

let input = '100-1'
let output = parser.parse(input)


let treeProcessor = new TreeProcessor()
let matchesOnly = treeProcessor.getRuleMatchesOnly(output)

debugger
for (let match of matchesOnly){
	treeProcessor.removeItemAndHeal(match, output)
}

//treeProcessor.recursiveApply(output, (matchNode)=>{matchNode.shallowDisplay()}, ()=>{return true})
/*
let matchesOnly = treeProcessor.getRuleMatchesOnly(output)

for (let i = 0; i < matchesOnly.length; i++){

}
//let imperfect
let ruleNodes = treeProcessor.returnAllNodes(matchesOnly, (ast)=>{ return ast.type == 'rule'})

for (ruleNode of ruleNodes){
	ruleNode.shallowDisplay()
}
*/
/*
let match_serial_numbers = []
for (let ruleNode of ruleNodes){
	match_serial_numbers.push(ruleNode.serial_number)
}

let testClosure = (function(){
	var _match_serial_numbers = match_serial_numbers
	var innerFunction = function(ast){
		return !_match_serial_numbers.includes(ast.id)
	}
	return innerFunction
})()


let nodesToDelete = treeProcessor.returnAllNodes(output, testClosure)
let idsOfNodesToDelete = nodesToDelete.map((astNode)=>astNode.serial_number)
*/

//let treeViewer = new TreeViewer(nodesToDelete, document.querySelector('#test'))
let treeViewer = new TreeViewer(output, document.querySelector('#test'))
treeViewer.display()

/*
let evaluateExpression = function(expressionTree){

}*/
</script>
</body>
</html>
