# H1 File Format

## Introduction

The H1 file format is a small language meant for describing parsers. This file contains a tutorial for using the H1 file format to describe a parser. While there are some concepts and related terminology that are used for describing parsers, in practice, writing these parsers was meant to be simple rather than difficult.

## Tutorial

### A simple example

#### Simple Example Part 1
Let's begin with a simple example for an H1 specification:

```
character class
 abc
```

This string describes a parser that is made up of a single mini-parser, of type 'character class'. This 'character class' mini-parser is configured to detect the characters 'a','b', and 'c'. When a string is passed on to the mini-parser, it will output some information to indicate whether or not the input string starts with the characters 'a','b','c', how many consecutive characters at the start of the string are one of 'a','b', and 'c', and what that string is. Please note that this definition of character class may be different from what you expect, but in the context of the Simple Parser Generator, a character class mini-parser checks how much of the beginning of an input string starts with one of a list of characters.

For example, let's say the input string is 'xyz'. This string does not start with 'a','b', or 'c', so the output from the character class mini-parser will be a piece of information that states that the string 'xyz' does not start with 'a','b', or 'c'. If, however, the input string is 'aaatta', then the mini-parser will return that the first three characters of the string 'aaatta' belong to the list of characters from the configuration list of 'a','b', and 'c'. Those three characters will be the string 'aaa'. The fourth 'a' in the string is not located at the front, so that is why the character class mini-parser will not detect it. The mini-parser's output will output this information in the form of an output object that the Simple Parser Generator sometimes refers to as a 'match object'. The exact format of the output object from a mini-parser is complicated, but for present purposes, all that is necessary to know is that an output object containing some information will be generated after parsing.

#### Simple Example Part 2

From a software-development point of view, 



'node' in the context of the  is a mini-parser that

That way is as follows: In other words, the parser generated by the above block of code will take in an input string, The first line is the name of a function. The second line is a piece of configuration information that tells the interpreter to detect

 argument that tells the function to determine whether a parameter. When an input string is passed in, the character class function will compare its run-time input letter by letter with the list of characters in the configuration parameter. As each letter of the input is compared, if the letter is one of the configuration parameters, then the next letter is compared. As soon as all the letters have been used up, or, there is a mismatch, a data object is returned. This data object will contain key-value pairs:

matchString:aaacccxxx
matchFound:false
parent:(null)
depth:0
inputString:aaacccxxx
type:entire
id:8
serial:7
matchFound: true


### A more complicated example

 letter is one of t with the c

A character class node is known as a micro-parser, that is, it can be thought of as a very simple, predefined parser--you can think of it as a function--that takes in a string as input and returns a piece of data after analyzing the input string. In this case, a character class node will behave as follows: is configured with the string "bcd", which me

An H1 file contains a series of root nodes
# Example file

* 'character class'
* 'string literal'
* 'or'
* 'sequence'
* 'and'
* 'multiple'
* 'not'
* 'optional'
* 'entire'



Rule List
 Rule
  rule name
   arbitrary rule name
  Multiple
   Character Class
    01234567890
